\section{Related Work}

Programmability of operating systems and networking resources, including
distributed storage systems is not new, but we are not aware of work that makes
generalization of existing services into programmable resources a key principle
in storage systems design. 

Programmable storage systems can be viewed as an infrastructure for creating
abstractions to better separate policies from mechanisms. This idea is not new.
Software-defined networks (SDNs) create such an abstraction by separating the
control plane from the data plane (see for example~\cite{jain:sigcomm13}). This
notion of control/data separation was also applied in software-defined storage
(SDS)~\cite{thereska:sosp13,stefanovici:fast16}. Similarly,
IOStack~\cite{gracia:internet16} is providing policy-based provisioning and
filtering in OpenStack Swift. According to a SNIA white
paper~\cite{carlson:snia2014}, the primary goal of SDS is to control and
facilitate flexible and dynamic provisioning of storage resources of different
kinds, including flash memory and disk drives, to create a virtual mapping
between common storage abstractions (e.g. files, objects, and blocks) and
storage devices taking data service objectives in terms of protection,
availability, performance, and security into account. A programmable storage
system exposes internal abstractions so that end users (not necessarily
operators) can create new services on top of the storage stack. Thus, our
notion of programmable storage differs from ``software-defined storage'' (SDS)
in terms of goals and scope, although definitions of SDS are still in flux.

Another view of programmable storage systems is one of tailoring systems
resources to applications~\cite{arpaci:sosp01}. Related efforts include the
Exokernel~\cite{engler:sosp95}, SPIN~\cite{bershad:sosp95} and
Vino~\cite{seltzer:osdi96} projects; the latter two addressed the ability of
injecting code into the kernel to specialize resource management. Another
approach is to pass hints between the different layers of the I/O stack to
bridge the semantic gap between applications and
storage~\cite{arpaci:sosp01,sivathanu:fast03,mesnier:sosp11}.

Malacology uses the same Active and Typed Storage module presented in
DataMods~\cite{watkins_datamods_2012}; Asynchronous Service and File Manifolds
can be implemented with small changes to the Malacology framework, namely
asynchronous object calls and Lua stubs in the inode, respectively.
