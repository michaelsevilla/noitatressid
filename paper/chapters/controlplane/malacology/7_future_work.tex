\section{Future Work}
 
\newcommentone{Malacology is a first step towards showing how general-purpose
storage systems can be adapted to target special-purpose applications.  By
encapsulating storage system functionality as reusable building blocks, we
enable application developers to leverage storage capabilities based on
interfaces that are proven and understandable.  However, creation and
composition of interfaces is complex; constructs must be combined safely in
order to provide correctness, performance and security. We will study
additional Malacology-based services in order to learn techniques that support
safe composition.}\addressesissue{5}
 
\newcommentone{Some higher-level services that we plan to build using the
interfaces in Table~\ref{table:examples} are: an elastic cloud database, a data
processing engine, and a data layout manager. Approaches proposed so far use
the Data I/O interface to push down predicates and computation, the File Type
interface to maintain access paths and metadata efficiently, and the Durability
interface to manage ingestion and movement. Using the programmable storage
approach helps us build higher-level services that work well with the storage
system not in spite of it.}
 
\newcommentone{ Our experience with ZLog and Mantle demonstrates that the labor
of wrapping existing services in reusable interfaces is justified by the power
and flexibility that this encapsulation affords to programmers.  In exchange
for this flexibility, however, programmers may forfeit the \emph{protection
from change} afforded by narrow storage interfaces such as the POSIX API.  To
implement applications on programmable storage systems such as Malacology,
programmers must find solutions by navigating a complex design space,
simultaneously addressing functional correctness, performance and fault
tolerance. Worse still, their solutions may be sensitive to changes in the
underlying environment, such as hardware upgrades, software version changes and
evolving workloads.  For example, a major version change in Ceph required us to
rewrite significant parts of ZLog to maintain acceptable performance. Each such
evolution costs developer time and risks introducing bugs.}
 
\newcommentone{We are actively exploring the use of high-level
\emph{declarative} languages based on Datalog~\cite{alvaro:cidr11} to program
data access and storage APIs.  Using this approach, a systems programmer can
specify the functional behavior in a relational (or algebraic) language,
allowing an optimizer to search through the space of functionally equivalent
physical implementations and select a good execution plan, re-optimizing when
storage characteristics or statistics change.  Much like query planning and
optimization in database systems~\cite{hellerstein:cidr15}, this approach will
separate the concerns of correctness and performance, protecting applications
(which usually evolve slowly) against changes in more dynamic storage system.}
\addressesissue{3}
